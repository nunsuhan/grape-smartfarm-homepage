[
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "d2e62ce4-485a-4ac9-a346-357b363bd485",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC001-Navigation Bar Dropdown Functionality on Desktop",
    "description": "Verify that the global navigation bar displays dropdown menus correctly on desktop devices and all links are functional.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Hover over each navigation menu item that has a dropdown to verify the dropdown menu appears.\n        frame = context.pages[-1]\n        # Hover over 'FarmSense' menu item to check for dropdown menu.\n        elem = frame.locator('xpath=html/body/main/footer/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try hovering over or clicking other navigation menu items that might have dropdown menus to check if any dropdown appears.\n        frame = context.pages[-1]\n        # Click or hover over 'contact@farmsense.io' to check for dropdown menu.\n        elem = frame.locator('xpath=html/body/main/footer/div/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dropdown menu loaded successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The global navigation bar dropdown menus did not appear as expected on hovering over menu items, or the dropdown links did not navigate correctly.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Dropdown menus in the global navigation bar on the FarmSense homepage do not appear on hover or click, preventing verification of their functionality and link navigation. This is a critical issue that blocks further testing. Reporting this issue and stopping the test as per instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151172947:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151172947:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151204783:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151204783:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151326081348//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.113Z",
    "modified": "2026-01-23T06:55:26.201Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "91acb954-9edd-4463-a208-9cc25e057586",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC002-Navigation Bar Responsiveness on Mobile",
    "description": "Ensure the navigation bar is fully responsive and operable on mobile devices with touch interactions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Simulate mobile device view and tap on the navigation bar menu icon to expand the menu.\n        frame = context.pages[-1]\n        # Click on the FarmSense logo or menu icon if it acts as a menu toggle for mobile navigation\n        elem = frame.locator('xpath=html/body/main/footer/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Navigation Menu Expanded Successfully')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The navigation bar did not expand or display all items correctly on mobile devices as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The navigation bar is not responsive or operable on mobile devices as the menu toggle does not expand the navigation menu. Further testing is stopped due to this critical issue.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151172945:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151172945:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151208790:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151208790:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151313279051//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.119Z",
    "modified": "2026-01-23T06:55:13.400Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "a9ba89e5-4903-4646-a5dc-e7cc5509fd92",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC003-Root Layout Global Styles Application",
    "description": "Validate that the root layout applies global styles and providers consistently across all pages of the application.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the technology blog page to validate global styles and providers consistency.\n        frame = context.pages[-1]\n        # Click on '기술력 (Technology)' link to navigate to the technology blog page\n        elem = frame.locator('xpath=html/body/main/section[5]/div[2]/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the water logic page to validate global styles and providers consistency.\n        frame = context.pages[-1]\n        # Click on '센서 연동 (Sensor Integration)' or relevant link to navigate to water logic page\n        elem = frame.locator('xpath=html/body/footer/div/div/div[2]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the yield logic page to validate global styles and providers consistency.\n        frame = context.pages[-1]\n        # Click on '지능형 로직 (Intelligent Logic)' link to navigate to yield logic page\n        elem = frame.locator('xpath=html/body/header[2]/div/nav/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the advanced education page to validate global styles and providers consistency.\n        frame = context.pages[-1]\n        # Click on '센서 교육 가이드 (Sensor Education Guide)' link to navigate to advanced education page\n        elem = frame.locator('xpath=html/body/header/div/nav/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the beginner education page to validate global styles and providers consistency.\n        frame = context.pages[-1]\n        # Click on 'Beginner 입문/초급 (DIY 기초)' link to navigate to beginner education page\n        elem = frame.locator('xpath=html/body/main/section[2]/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=기술력 (Technology)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 교육 가이드').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=지능형 로직').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=DIY Sensor Course').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=입문자를 위한 ESP32 센서 만들기').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1만원짜리 보드(ESP32)와 온습도 센서(DHT22)로 나만의 스마트팜 센서를 만들어보세요.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=복잡한 코딩 없이, '복사'해서 '붙여넣기'하면 끝납니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=펌웨어 전체 코드 (Copy & Paste)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=아래 코드는 DHT22 센서 값을 읽어 FarmSense 서버로 전송하는 전체 코드입니다.SSID와 PASSWORD 부분만 내 농장의 와이파이 정보로 수정하세요.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=설정이 어려우신가요?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI에게 사진을 찍어 물어보세요').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151404366685//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.125Z",
    "modified": "2026-01-23T06:56:44.512Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "4406f2fb-260b-4e00-b200-de6e573c6e34",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC004-Water Logic Page Content and Layout Verification",
    "description": "Ensure the Water Logic technical blog page renders with correct detailed content and consistent layout.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and click the link or menu item to navigate to the Water Logic blog page.\n        await page.mouse.wheel(0, 500)\n        \n\n        # -> Click the '의사결정 지원 (DSS)' link to navigate to the Water Logic technical blog page.\n        frame = context.pages[-1]\n        # Click on '의사결정 지원 (DSS)' link to go to Water Logic blog page\n        elem = frame.locator('xpath=html/body/main/section[5]/div[2]/div[2]/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to check for additional content, images, code examples, and footer presence and consistency.\n        await page.mouse.wheel(0, 800)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=토양 수분 장력(pF)과 일사량 기반의 증발산량(ET) 계산법을 적용합니다. 작물이 실제 필요로 하는 물의 양을 \\'리터(L)\\' 단위로 정확히 제안하여 과잉 관수 및 비료 유실을 방지합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense는 단순 진단을 넘어섭니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Core Algorithm Logic').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Deep Logic, Transparent Output').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=예측 결과는 수집된 데이터와 알고리즘에 기반한 분석 추정치입니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2025 FarmSense. All rights reserved.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151322165185//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.153Z",
    "modified": "2026-01-23T06:55:22.331Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "3a779b24-0839-4988-b110-ad1da12aadc0",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC005-Yield Prediction Page Content and Layout Verification",
    "description": "Verify the Yield Prediction technical blog page displays content about GDD and AI vision yield prediction accurately with correct layout.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find and click the link or menu item that leads to the Yield Prediction blog page.\n        frame = context.pages[-1]\n        # Click on the 의사결정 지원 (DSS) link which mentions GDD Algorithm and PMI Prediction, likely related to Yield Prediction.\n        elem = frame.locator('xpath=html/body/main/section[5]/div[2]/div[2]/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to locate and verify content specifically about Growing Degree Days (GDD) and AI vision yield prediction. Check images and layout consistency.\n        await page.mouse.wheel(0, 600)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=VitiCanopy & Yield Algo').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=스마트폰 사진으로 수관 밀도와 공극률을 분석해 광합성 효율과 엽면적(LAI)을 추정, 최종 예상 수확량 계산.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Core Algorithm Logic').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense는 단순 진단을 넘어섭니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2025 FarmSense. All rights reserved.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151291414226//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.159Z",
    "modified": "2026-01-23T06:54:51.564Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "04bfad9b-e70b-48f6-b544-073eff2ca6c1",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC006-Sensor Education Beginner Guide Content Validation",
    "description": "Confirm the Beginner sensor guide page for building ESP32 sensors is complete, accurate, and properly formatted.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the '센서 교육 가이드' (Sensor Education Guide) menu to access the Beginner sensor guide page.\n        frame = context.pages[-1]\n        # Click on the '센서 교육 가이드' (Sensor Education Guide) menu item to open the sensor education beginner guide page.\n        elem = frame.locator('xpath=html/body/main/footer/div/div/div[2]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to review the full ESP32 sensor building steps, code snippets, images, and explanatory text for completeness and formatting.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll further down to check the ESP32 sensor building steps, code snippets, images, and explanatory text for completeness and proper formatting.\n        await page.mouse.wheel(0, 1000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=센서 교육 가이드').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Smart Sensors').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=IoT Network & Environmental Monitoring: 초정밀 센서 기술로 완성하는 보이지 않는 곳의 관리').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=400M+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=12 types').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=94%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Why Smart Sensors?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=기존 방식').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=감각 의존: \"대충 덥네/습하네\" 느낌으로 판단하여 오차 발생').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=수동 관리: 하루 종일 하우스에 붙어서 창을 열고 닫아야 하는 노동').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=사후 약방문: 이미 고온 장애나 냉해를 입은 후에야 문제 인지').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense IoT').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=정밀 데이터: 12가지 환경 변수를 1분 단위로 0.1% 오차범위 내 측정').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=자동 제어: 설정값에 따라 측창/보온커튼/관수 등을 24시간 자동 제어').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=이상 감지: 장비 고장이나 급격한 환경 변화 시 즉시 스마트폰 알림').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=How It Works').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1. Sensing').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=온도, 습도, CO2, 지온, 지습 등 12가지 핵심 환경 변수를 1분 단위로 오차 범위 0.1% 내에서 측정합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2. Transmission').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=LoRaWAN 저전력 장거리 통신 기술을 사용하여 통신 비용 없이 반경 2km 내의 데이터를 안정적으로 전송합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3. Processing').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=수집된 데이터는 엣지 디바이스에서 1차 보정 후 클라우드로 전송되어 이상 징후를 즉시 판별합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Massive IoT Grid').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Multi-Sensor Fusion').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=단일 센서의 오차를 최소화하기 위해 다중 센서 간의 상관관계를 분석하여 데이터 무결성을 검증합니다. (예: 일사량과 온도의 관계 분석)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Automated Calibration').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 노후화에 따른 드리프트 현상을 AI가 자동으로 감지하고 보정하여 장기간 사용에도 초기 성능을 유지합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Robust Hardware').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=IP67 방수/방진 등급의 하드웨어 설계로 고온다습한 하우스 환경과 외부 노지 환경에서도 내구성을 보장합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Use Cases').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=정밀 환경 제어').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=\"하우스 온도는 맞는데 작물 상태가 왜 이럴까요?\"').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=→ 공기 온도가 아닌 '엽온(잎의 온도)'과 '근권 수분(뿌리 근처 수분)'을 측정하여 식물이 실제로 느끼는 스트레스를 94%의 정확도로 감지해 냅니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=장비 고장 조기 경보').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=\"겨울밤 보일러가 고장난 줄 모르고 잤다가 냉해를 입었습니다.\"').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=→ 온도가 설정 범위 밖으로 급격히 떨어지는 패턴을 즉시 감지하여 새벽 2시에도 전화 알림을 발송하여 치명적인 사고를 막았습니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Related Papers').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=01').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Wireless sensor networks for agriculture').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Ojha et al., Computers and Electronics in Agriculture 2015').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=02').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TimescaleDB Documentation').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Timescale, 2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=03').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=스마트팜코리아').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=농림축산식품부, 공식 사이트').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=자주 묻는 질문').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=설치가 어렵지 않은가요?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=전기 공사가 필요한가요?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=정전이 되어도 작동하나요?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=타사 제어기(컨트롤러)와 호환 되나요?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=보이지 않는 것까지 관리하세요').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense IoT 센서가 24시간 당신의 농장을 지켜드립니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=시연 신청하기').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI가 포도를 이해합니다').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=contact@farmsense.io').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=대한민국').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=기술').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=RAG 시스템').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI 진단').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=병해 예측').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 연동').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=데이터 전략').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=서비스').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=서비스 소개').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=제품 소개').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=고객지원').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FAQ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI 스마트 도우미').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1:1 문의').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=제휴 문의').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=시연 신청').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2025 FarmSense. All rights reserved.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151338215448//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.168Z",
    "modified": "2026-01-23T06:55:38.358Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "54dc8ee9-9c7f-4913-a91d-aab1e19dab12",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC007-Sensor Education Advanced Guide Content Validation",
    "description": "Validate the Advanced sensor guide page for integrating LoRa and RS-485 sensors is accurate, well structured and content complete.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on '센서 교육 가이드' (Sensor Education Guide) link to access the advanced guide page.\n        frame = context.pages[-1]\n        # Click on '센서 연동' (Sensor Integration) or '센서 교육 가이드' (Sensor Education Guide) link to navigate to the advanced sensor guide page.\n        elem = frame.locator('xpath=html/body/main/footer/div/div/div[2]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the '센서 교육 가이드' link (index 13) to open the advanced sensor guide page.\n        frame = context.pages[-1]\n        # Click on '센서 교육 가이드' link to navigate to the advanced sensor guide page.\n        elem = frame.locator('xpath=html/body/header[2]/div/nav/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to locate detailed instructions on LoRa and RS-485 sensor integration and verify their presence and completeness.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Click on the 'Advanced 중급/고급 (API/LoRa)' link (index 10) to try to access the advanced sensor guide content for LoRa and RS-485 integration.\n        frame = context.pages[-1]\n        # Click on 'Advanced 중급/고급 (API/LoRa)' link to open the advanced sensor guide page with LoRa and RS-485 integration details.\n        elem = frame.locator('xpath=html/body/main/section[2]/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Advanced Integration').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=LoRa, RS-485 등 산업용 통신 프로토콜을 사용하는 센서를 FarmSense 게이트웨이에 연결하거나 기존에 사용 중인 타사 센서 데이터를 API로 전송하는 방법을 안내합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense는 KR920-923MHz 주파수 대역을 표준으로 사용합니다.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=from pymodbus.client.sync import ModbusSerialClient').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=def read_soil_sensor(port='/dev/ttyUSB0'):').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=수집한 데이터를 FarmSense 클라우드로 보내는 방법을 확인하세요.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=API 문서 보기').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=KT 스마트팜 연동').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 등록 오류 해결').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151352923744//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.251Z",
    "modified": "2026-01-23T06:55:53.066Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "44cef235-c0a9-4990-a34c-b87b43e05032",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC008-Technology Blog Footer Links and Layout",
    "description": "Verify that the technology blog footer is displayed on relevant pages and contains functional links to support and additional info.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down to locate the footer on the homepage and verify its visibility and style.\n        await page.mouse.wheel(0, 1000)\n        \n\n        # -> Navigate to the Water Logic page to verify footer presence and links.\n        frame = context.pages[-1]\n        # Click on '지능형 로직' (Intelligent Logic) menu to navigate to Water Logic page\n        elem = frame.locator('xpath=html/body/header/div/nav/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to fully reveal the footer area on the Water Logic page.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Click on the 'FAQ' footer link to verify navigation to the correct support page.\n        frame = context.pages[-1]\n        # Click on 'FAQ' link in the footer to verify navigation\n        elem = frame.locator('xpath=html/body/footer/div/div/div[4]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'AI 스마트 도우미' footer link to verify navigation to the correct support page.\n        frame = context.pages[-1]\n        # Click on 'AI 스마트 도우미' link in the footer to verify navigation\n        elem = frame.locator('xpath=html/body/footer/div/div/div[4]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to reveal the footer on the AI 스마트 도우미 support page and verify its visibility and content.\n        await page.mouse.wheel(0, 1000)\n        \n\n        # -> Navigate to the Yield Prediction page to verify footer presence and functionality there.\n        frame = context.pages[-1]\n        # Click on 'Hybrid AI Stacking' or Yield Prediction link to navigate to Yield Prediction page\n        elem = frame.locator('xpath=html/body/main/section[2]/div/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to reveal the footer on the Yield Prediction page and verify its visibility and content.\n        await page.mouse.wheel(0, 900)\n        \n\n        # -> Click on the 'FAQ' footer link to verify navigation to the correct support page.\n        frame = context.pages[-1]\n        # Click on 'FAQ' link in the footer to verify navigation\n        elem = frame.locator('xpath=html/body/footer/div/div/div[4]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the '1:1 문의' footer link to verify navigation to the correct support page.\n        frame = context.pages[-1]\n        # Click on '1:1 문의' link in the footer to verify navigation\n        elem = frame.locator('xpath=html/body/footer/div/div/div[4]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=FarmSense').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=문제 정의').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=기술력 (Technology)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 교육 가이드').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=지능형 로직').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=주요 기능').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=도입 안내').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=회사 소개').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=고객지원').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FAQ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI 스마트 도우미').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1:1 문의').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=문의하기').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2025 FarmSense. All rights reserved.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151508810319//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.346Z",
    "modified": "2026-01-23T06:58:28.985Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "4801b83a-8cfc-4133-9b31-5d7737fb24bd",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC009-Contact Modal Open, Input, and Close Behavior",
    "description": "Test that the global contact modal opens on user action, accepts inputs correctly, and closes as expected.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the UI element that triggers the contact modal.\n        frame = context.pages[-1]\n        # Click the '도입 문의하기' button to open the contact modal.\n        elem = frame.locator('xpath=html/body/main/section[6]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Contact Modal Successfully Opened')).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The global contact modal did not open, accept inputs, or close as expected as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped because the global contact modal did not open upon clicking the expected trigger button '도입 문의하기'. This prevents further testing of input acceptance, submission, and modal closing behaviors. Please investigate and fix the modal trigger issue.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151205888:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151205888:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151308953934//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.355Z",
    "modified": "2026-01-23T06:55:09.083Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "d73bed7b-0027-4925-81e8-ec1dfca28650",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC010-Global Modal Management - Multiple Modal Handling",
    "description": "Assess the global modal provider's ability to handle multiple modal interactions without UI conflicts.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Trigger the contact modal by clicking the '도입 문의하기' button (index 14)\n        frame = context.pages[-1]\n        # Click the '도입 문의하기' button to trigger the contact modal.\n        elem = frame.locator('xpath=html/body/main/section[6]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to open a second modal, such as the accessibility modal, by clicking the 'AI 스마트 도우미' button (index 46) to test multiple modal handling.\n        frame = context.pages[-1]\n        # Click the 'AI 스마트 도우미' button to attempt opening a second modal.\n        elem = frame.locator('xpath=html/body/main/footer/div/div/div[4]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the currently open AI 스마트 도우미 modal to verify proper modal closing and focus restoration.\n        frame = context.pages[-1]\n        # Click the 'Toggle menu' button or a close button if available to close the AI 스마트 도우미 modal.\n        elem = frame.locator('xpath=html/body/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to the main page to retry triggering the contact modal.\n        frame = context.pages[-1]\n        # Click the 'FarmSense' logo link to navigate back to the main page.\n        elem = frame.locator('xpath=html/body/header/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the '도입 문의하기' button (index 14) again to retry triggering the contact modal.\n        frame = context.pages[-1]\n        # Click the '도입 문의하기' button to retry triggering the contact modal.\n        elem = frame.locator('xpath=html/body/main/section[6]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Multiple Modals Opened Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The global modal provider did not handle multiple modal interactions correctly. Expected multiple modals to stack properly or only one modal to be open at a time as per design, but this was not observed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The contact modal could not be triggered despite multiple attempts, and the page content remains unexpectedly minimal after clicking the trigger button. The AI 스마트 도우미 modal was tested successfully, but without the contact modal, full assessment of multiple modal handling is not possible. The issue has been reported. Task stopped.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151206835:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151206835:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151270846:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151270846:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151310526:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151310526:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/176915145501102//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.445Z",
    "modified": "2026-01-23T06:57:35.148Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "9730caa2-ea43-497e-abdc-f84f64d69bbe",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC011-Page Navigation Using Global Navigation Bar",
    "description": "Validate user can navigate to homepage, technology blog sections, and education guides using the global navigation bar without errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> From homepage, click navigation bar link to Technology Blog section.\n        frame = context.pages[-1]\n        # Click navigation bar link to Technology Blog section (기술력 (Technology))\n        elem = frame.locator('xpath=html/body/main/section[2]/div/div/div[2]/form/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Use navigation bar to access Sensor Education Beginner guide.\n        frame = context.pages[-1]\n        # Click navigation bar link to Sensor Education Beginner guide (센서 교육 가이드)\n        elem = frame.locator('xpath=html/body/header/div/nav/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to homepage via navigation bar.\n        frame = context.pages[-1]\n        # Click navigation bar link to homepage (FarmSense) to navigate back to homepage\n        elem = frame.locator('xpath=html/body/header/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=기술력 (Technology)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 교육 가이드').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151365927494//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.451Z",
    "modified": "2026-01-23T06:56:06.093Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "dd83a773-3cf5-4ba3-a4c6-52666a1f1b7d",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC012-Deployment Verification on Vercel",
    "description": "Check that deployment to Vercel completes successfully with proper domain configuration and environment variables.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Push code changes to GitHub repository to trigger deployment on Vercel.\n        await page.goto('https://github.com/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input GitHub username and password, then sign in.\n        frame = context.pages[-1]\n        # Input GitHub username\n        elem = frame.locator('xpath=html/body/div/div[4]/main/div/div[2]/form/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('artmer3061@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input GitHub password\n        elem = frame.locator('xpath=html/body/div/div[4]/main/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('msm3061@@')\n        \n\n        frame = context.pages[-1]\n        # Click Sign in button\n        elem = frame.locator('xpath=html/body/div/div[4]/main/div/div[2]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the repository grape-smartfarm-homepage to push code changes.\n        frame = context.pages[-1]\n        # Click on repository 'nunsuhan/grape-smartfarm-homepage' to open it\n        elem = frame.locator('xpath=html/body/div/div[6]/div/div/aside/div/div/loading-context/div/div/div/div/ul/li/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Push code changes to GitHub repository to trigger deployment on Vercel.\n        frame = context.pages[-1]\n        # Click 'Go to file' input to open file selector\n        elem = frame.locator('xpath=html/body/div/div[6]/div/main/turbo-frame/div/div/div/div/div/react-partial/div/div/div[2]/div[2]/div/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Deployment Successful! Your site is live.').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Deployment to Vercel did not complete successfully with proper domain configuration and environment variables as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to check deployment to Vercel cannot proceed because pushing code changes to GitHub to trigger deployment is not possible via the current web interface. No deployment logs or domain configuration could be verified. Task stopped.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151209313:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151209313:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://github.com/github-copilot/chat/token:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/176915145061473//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.457Z",
    "modified": "2026-01-23T06:57:30.743Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "a9d2fa18-aa0e-4424-8609-193d07eea42c",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC013-GitHub Repository Sync with Deployment Pipeline",
    "description": "Ensure that commits pushed to the GitHub repository trigger the deployment pipeline without sync issues.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Deployment Successful!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The deployment pipeline did not trigger automatically after the commit push, or sync/webhook failures were detected as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The FarmSense main page loaded successfully. Next, I will simulate making a commit and pushing it to the GitHub main branch to trigger the deployment pipeline and verify automatic deployment.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151211076:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151211076:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151264063684//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.463Z",
    "modified": "2026-01-23T06:54:24.214Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "44f758cf-e3ec-457a-b93a-3e2b16b67a9d",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC014-Image and Asset Load Performance and Size Compliance",
    "description": "Validate all images and assets load efficiently within size restrictions and do not degrade performance across devices.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Load next page among recently modified pages (water logic, yield logic, advanced education, beginner education) to repeat image and asset validation.\n        frame = context.pages[-1]\n        # Click on '데이터 기반 병해 진단 Data Helper' link to navigate to a recently modified page for further image validation\n        elem = frame.locator('xpath=html/body/main/section[5]/div[2]/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the next recently modified page (e.g., water logic) to continue image and asset validation.\n        frame = context.pages[-1]\n        # Click on 'AI 진단' link to navigate to the next recently modified page for validation\n        elem = frame.locator('xpath=html/body/footer/div/div/div[2]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All images loaded successfully without any errors or broken links').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Images and assets did not load efficiently or within size restrictions, causing performance degradation as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Navigation issue detected on the AI diagnosis page. Clicking the 'AI 진단' link does not navigate to a new page or change content, preventing further validation of images and assets on other recently modified pages. So far, 2 pages have been validated with images loading correctly and optimized. Stopping further actions until the issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151211284:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151211284:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app/technology/layout.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151256329:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151256329:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app/technology/layout.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/css/css-app_globals_css-node_modules_next_font_google_target_css-node_modules_next_font_google_ta-a7ec92.css?v=1769151312489:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/_next/static/chunks/main-app.js?v=1769151312489:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151437026256//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.469Z",
    "modified": "2026-01-23T06:57:17.192Z"
  },
  {
    "projectId": "8cb4b4d4-5930-4d97-884a-79f6f1d78aac",
    "testId": "4f1ffc19-ce77-4ae4-9400-45aec7bdbbc1",
    "userId": "24b85498-9061-709b-7c52-45ad0a7206d8",
    "title": "TC015-Error Handling for Broken Navigation Links",
    "description": "Test that the application handles navigation to non-existent or invalid URLs gracefully with proper error or 404 pages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Manually enter an invalid URL within the app domain to test 404 or error page handling.\n        await page.goto('http://localhost:3000/nonexistentpage123', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Manually enter another invalid URL within the app domain to continue testing 404 or error page handling.\n        await page.goto('http://localhost:3000/invalidpage456', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Manually enter a third invalid URL within the app domain to continue testing 404 or error page handling.\n        await page.goto('http://localhost:3000/removedpage789', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Manually enter the last invalid URL within the app domain to complete invalid URL testing.\n        await page.goto('http://localhost:3000/nonexistentpage999', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Use the navigation bar to attempt to access any temporarily removed or broken links, especially on recently modified pages, to verify error handling and user feedback.\n        frame = context.pages[-1]\n        # Click on '지능형 로직' (Intelligent Logic) in the navigation bar to check for broken or temporarily removed links.\n        elem = frame.locator('xpath=html/body/header/div/nav/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test navigation bar links for 'water logic', 'yield logic', 'advanced education', and 'beginner education' pages to verify error handling and user feedback for broken or temporarily removed links.\n        frame = context.pages[-1]\n        # Click on 'Hybrid AI Stacking' (Yield logic) link in the navigation bar to check for broken or temporarily removed links.\n        elem = frame.locator('xpath=html/body/main/section[2]/div/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the navigation bar link for 'water logic' to check for broken or temporarily removed links.\n        frame = context.pages[-1]\n        # Click on '센서 교육 가이드' (Sensor Education Guide) which corresponds to 'water logic' or related recently modified page.\n        elem = frame.locator('xpath=html/body/header/div/nav/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to a known invalid URL to extract and analyze the 404 error page text content and contrast.\n        await page.goto('http://localhost:3000/nonexistentpage123', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=404').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=This page could not be found.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FarmSense').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=문제 정의').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=기술력 (Technology)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=센서 교육 가이드').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=지능형 로직').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=주요 기능').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=도입 안내').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=회사 소개').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=고객지원').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24b85498-9061-709b-7c52-45ad0a7206d8/1769151396055959//tmp/test_task/result.webm",
    "created": "2026-01-23T06:52:49.475Z",
    "modified": "2026-01-23T06:56:36.207Z"
  }
]
